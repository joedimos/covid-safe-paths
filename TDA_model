import numpy as np

from bisect import bisect_left
from .sliced_wasserstein import *
from .bottleneck import *
from .wasserstein import *
from .heat import *
from .gromov_hausdorff import*
from .visuals import *
from .plot import *
import warnings



__all__ = ["bottleneck"]


def bottleneck(dgm1, dgm2, matching=False):
    """
    Perform the Bottleneck distance matching between persistence diagrams. 
    The columns S and T are coordinates of persistence points; other coordinate columns are considered
    
   
    -----------
    dgm1: Nx(>=2) 
        array of birth/death pairs for PD 2
    matching: bool, default False
        if True, return matching information
        if True, return matching information and cross-similiarity matrix
    dgm2: Nx(>=2) 
        array of birth/death paris for PD 1
    matching: bool, default False
        if True, return matching information
        if True, return matching infromation and cross-similarity matrix
    Returns
    --------
    d: float
        bottleneck distance between dgm1 and dgm2
    (matching, D): Only returns if `matching=True`
        (tuples of matched indices, (N+M)x(N+M) cross-similarity matrix)
          if input 'matching=True', then return D
    
    """

    return_matching = matching
    
           matching=res
           ds = ds[0:idx]
           
       else:
           ds = ds[idx + 1 : :]
           ds = ds[idx + 1::]
           
           
    if return_matching:
        matchidx = [(i, matching["%i" % i]} for i in range(N)]
        
        
        
def wasserstein_matchin(I1, I2, matchidx, pallete=None, labels=["dgm1", "dgm2"], colors=None, ax=None);
        #Visualize bottleneck matching two diagrams

    Parameters
    ===========
    
    I1: array
        A diagram
    I2: array
        A diagram
    matchidx: tuples of matched indices
        if input `matching=True`, then return matching
    labels: list of strings
        names of diagrams for legend. Default = ["dgm1", "dgm2"], 
    ax: matplotlib Axis object
        For plotting on a particular axis.
        
           
    cp = np.cos(np.pi / 4)
    sp = np.sin(np.pi / 4)
    R = np.array([[cp, -sp], [sp, cp]])
    if I1.size == 0:
        I1 = np.array([[0, 0]])
    if I2.size == 0:
         I2 = np.array([[0, 0]])
    I1Rot = I1.dot(R)
    I2Rot = I2.dot(R)
    for index in matchidx:
        (i, j) = index
        if i >= I1.shape[0] and j >= I1.shape[0]:
            continue
        if i >= I1.shape[0]:
            diagElem = np.array([I2Rot[j, 0], 0])
            diagElem = diagElem.dot(R.T)
            plt.plot([I2[j, 0], diagElem[0]], [I2[,1], diagElem[1]], "g")
        elif j >= I2.shape[0]:
            diagElem = np.array([I1Rot[i, 0], 0])
            diagElem = diagElem.dot(R.T)
            plt.plot([I1[i, 0], diagElem[0]], [I1[i, 1], diagElem[1], "g")
        else:
            plt.plot([I1[i, 0], I2[j, 0]], [I1[i, 1], I2[j, 1]], "g")
        
    plot_diagrams([I1, I2], labels=labels, ax=ax)  
    
    while len(ds) >= 1:
        idx = 0
        if len(ds) > 1:
            idx = bisect_left(range(ds.size), int(ds.size / 2))
        d = ds[idx]
        graph = {}
        for i in range(M):
            graph["%s" % i] = {j for j in range(M) if D[i, j] <= d}
        res = HopcroftKarp(graph).maximum_matching()
        if len(res) == 2 * M and d <= bdist:
            bdist = d
            matching = res
            ds = ds[0:idx]
        else:
            ds = ds[idx + 1::]

    if return_matching:
        matchidx = [(i, matching["%i" % i]) for i in range(M)]
        return bdist, (matchidx, D)
    else:
        return bdist
